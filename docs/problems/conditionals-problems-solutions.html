<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Control flow | Learning Python</title>
<meta name="generator" content="Jekyll v3.7.2" />
<meta property="og:title" content="Control flow" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="True/False questions boolean variables can have three values: True, False and Undefined. False: Boolean values are binary, True or False. The contains operator checks whether a certain element is inside a collection. False: in checks for inclusion in a collection following the format item in collection. Because they are not primitives, strings cannot be compared using == and !=. False: While strings are not primitives, they can be compared using the == and != operators. Simple statements can be combined using and and or to build more complex boolean expressions. True: Using and and or can help you combine simple statements into composite statements. A boolean expression always evaluates to a boolean value. True: This separates their operators from the other arithmetic operators. if blocks cannot be used alone; they need an accompanying else block. False: if blocks are independent and do not need else blocks. elsif blocks allow you to add “alternative conditions” to be evaluated if the ones above are False. False: elif allows this, elsif isn’t a valid keyword. The following block would only print Foo: value = 5 if value &lt; 10 and value &gt; 2: print(&quot;Foo&quot;) if value &lt; 20: print(&quot;Bar&quot;) elif value &lt; 30: print(&quot;Baz&quot;) else: print(&quot;Bat&quot;) False: if blocks are independent from each other. As such, they are all evaluated. else and elif are the dependent blocks. The function of elif and else blocks can be emulated using if blocks only, but it is much less efficient. True: Using conditions, it’s possible to emulate elif and else, but the syntax is cumbersome. User input using input() is non-blocking: the script will continue running and will not wait for the user’s input unless the value is used in a later statement. False: input() is blocking. Once reached, an input() call will cause the script to wait until an input is given. input() can produce integers, floats or strings, depending on the type parameter given to it. False: input() produces strings, which can then be converted at-will. Short answer questions Explain the role of indentation in blocks such as if/elif/else. Indentation is used to delimit what code is part of blocks, it replaces the usage of braces in other languages like C and Java. Indentation however needs to be consistent for the interpreter to recognize when a block ends. Detail one practical example of how conditional statements can be used in scripts. Conditional statements can be used to validate data and prevent crashes: if a value isn’t valid, further operation can be prevented such that no erroneous values or unpredicted behaviour takes place. What happens if a conversion function such as int() is used on a value that does not contain a number? If int() is used on a non-numerical value, a ValueError will be raised signalling that an invalid value was given to the function int(). This will stop the script’s execution. Programming questions Revisit the temperature conversion problem of the last problem set and implement input validation for each of your conversion functions. If the value given to your function is below the minimum acceptable value, you should return the lowest converted value possible, and if the value is above the maximum acceptable value, you should return the highest converted value possible. Think of what the bounds of your input should be. Solution: pbset2_q1.py Using a combination of conditional statements, write a function that converts numerical grades to letter grades. Your overall script should use user input methods to ask the user for a numerical grade to convert and should print out a sentence in which the original entered grade and the converted garde are embedded. Solution: pbset2_q2.py If your solution in 2. used composite expressions as conditions, can you rework if such that only simple expressions are used? Solution: pbset2_q3.py Recursion is the idea that a function can call itself. By modifying the parameters that are provided to the “inside” call, we can modulate how many times a certain function will run. For example, we can write the following function: def sum_numbers_between(a,b): if a == b: return a else: return a + sum_numbers_between(a+1,b) my_sum = sum_numbers_between(0, 10) print(my_sum) In this scenario, each call of the function either returns a if the range is only composed of a (i.e. if the range has a == b) or a + sum_numbers_between(a+1,b). In the second case, note that a is incremented: this ensures that it will at some point satisfy the first condition. Using the same idea as the one exposed in the snippet above, build a function that sums up all the even numbers between two values a and b where a &lt;= b. Solution: pbset2_q4.py" />
<meta property="og:description" content="True/False questions boolean variables can have three values: True, False and Undefined. False: Boolean values are binary, True or False. The contains operator checks whether a certain element is inside a collection. False: in checks for inclusion in a collection following the format item in collection. Because they are not primitives, strings cannot be compared using == and !=. False: While strings are not primitives, they can be compared using the == and != operators. Simple statements can be combined using and and or to build more complex boolean expressions. True: Using and and or can help you combine simple statements into composite statements. A boolean expression always evaluates to a boolean value. True: This separates their operators from the other arithmetic operators. if blocks cannot be used alone; they need an accompanying else block. False: if blocks are independent and do not need else blocks. elsif blocks allow you to add “alternative conditions” to be evaluated if the ones above are False. False: elif allows this, elsif isn’t a valid keyword. The following block would only print Foo: value = 5 if value &lt; 10 and value &gt; 2: print(&quot;Foo&quot;) if value &lt; 20: print(&quot;Bar&quot;) elif value &lt; 30: print(&quot;Baz&quot;) else: print(&quot;Bat&quot;) False: if blocks are independent from each other. As such, they are all evaluated. else and elif are the dependent blocks. The function of elif and else blocks can be emulated using if blocks only, but it is much less efficient. True: Using conditions, it’s possible to emulate elif and else, but the syntax is cumbersome. User input using input() is non-blocking: the script will continue running and will not wait for the user’s input unless the value is used in a later statement. False: input() is blocking. Once reached, an input() call will cause the script to wait until an input is given. input() can produce integers, floats or strings, depending on the type parameter given to it. False: input() produces strings, which can then be converted at-will. Short answer questions Explain the role of indentation in blocks such as if/elif/else. Indentation is used to delimit what code is part of blocks, it replaces the usage of braces in other languages like C and Java. Indentation however needs to be consistent for the interpreter to recognize when a block ends. Detail one practical example of how conditional statements can be used in scripts. Conditional statements can be used to validate data and prevent crashes: if a value isn’t valid, further operation can be prevented such that no erroneous values or unpredicted behaviour takes place. What happens if a conversion function such as int() is used on a value that does not contain a number? If int() is used on a non-numerical value, a ValueError will be raised signalling that an invalid value was given to the function int(). This will stop the script’s execution. Programming questions Revisit the temperature conversion problem of the last problem set and implement input validation for each of your conversion functions. If the value given to your function is below the minimum acceptable value, you should return the lowest converted value possible, and if the value is above the maximum acceptable value, you should return the highest converted value possible. Think of what the bounds of your input should be. Solution: pbset2_q1.py Using a combination of conditional statements, write a function that converts numerical grades to letter grades. Your overall script should use user input methods to ask the user for a numerical grade to convert and should print out a sentence in which the original entered grade and the converted garde are embedded. Solution: pbset2_q2.py If your solution in 2. used composite expressions as conditions, can you rework if such that only simple expressions are used? Solution: pbset2_q3.py Recursion is the idea that a function can call itself. By modifying the parameters that are provided to the “inside” call, we can modulate how many times a certain function will run. For example, we can write the following function: def sum_numbers_between(a,b): if a == b: return a else: return a + sum_numbers_between(a+1,b) my_sum = sum_numbers_between(0, 10) print(my_sum) In this scenario, each call of the function either returns a if the range is only composed of a (i.e. if the range has a == b) or a + sum_numbers_between(a+1,b). In the second case, note that a is incremented: this ensures that it will at some point satisfy the first condition. Using the same idea as the one exposed in the snippet above, build a function that sums up all the even numbers between two values a and b where a &lt;= b. Solution: pbset2_q4.py" />
<link rel="canonical" href="https://mcataford.github.io/TalkPythonToMe/problems/conditionals-problems-solutions.html" />
<meta property="og:url" content="https://mcataford.github.io/TalkPythonToMe/problems/conditionals-problems-solutions.html" />
<meta property="og:site_name" content="Learning Python" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-02-12T10:05:23-05:00" />
<script type="application/ld+json">
{"description":"True/False questions boolean variables can have three values: True, False and Undefined. False: Boolean values are binary, True or False. The contains operator checks whether a certain element is inside a collection. False: in checks for inclusion in a collection following the format item in collection. Because they are not primitives, strings cannot be compared using == and !=. False: While strings are not primitives, they can be compared using the == and != operators. Simple statements can be combined using and and or to build more complex boolean expressions. True: Using and and or can help you combine simple statements into composite statements. A boolean expression always evaluates to a boolean value. True: This separates their operators from the other arithmetic operators. if blocks cannot be used alone; they need an accompanying else block. False: if blocks are independent and do not need else blocks. elsif blocks allow you to add “alternative conditions” to be evaluated if the ones above are False. False: elif allows this, elsif isn’t a valid keyword. The following block would only print Foo: value = 5 if value &lt; 10 and value &gt; 2: print(&quot;Foo&quot;) if value &lt; 20: print(&quot;Bar&quot;) elif value &lt; 30: print(&quot;Baz&quot;) else: print(&quot;Bat&quot;) False: if blocks are independent from each other. As such, they are all evaluated. else and elif are the dependent blocks. The function of elif and else blocks can be emulated using if blocks only, but it is much less efficient. True: Using conditions, it’s possible to emulate elif and else, but the syntax is cumbersome. User input using input() is non-blocking: the script will continue running and will not wait for the user’s input unless the value is used in a later statement. False: input() is blocking. Once reached, an input() call will cause the script to wait until an input is given. input() can produce integers, floats or strings, depending on the type parameter given to it. False: input() produces strings, which can then be converted at-will. Short answer questions Explain the role of indentation in blocks such as if/elif/else. Indentation is used to delimit what code is part of blocks, it replaces the usage of braces in other languages like C and Java. Indentation however needs to be consistent for the interpreter to recognize when a block ends. Detail one practical example of how conditional statements can be used in scripts. Conditional statements can be used to validate data and prevent crashes: if a value isn’t valid, further operation can be prevented such that no erroneous values or unpredicted behaviour takes place. What happens if a conversion function such as int() is used on a value that does not contain a number? If int() is used on a non-numerical value, a ValueError will be raised signalling that an invalid value was given to the function int(). This will stop the script’s execution. Programming questions Revisit the temperature conversion problem of the last problem set and implement input validation for each of your conversion functions. If the value given to your function is below the minimum acceptable value, you should return the lowest converted value possible, and if the value is above the maximum acceptable value, you should return the highest converted value possible. Think of what the bounds of your input should be. Solution: pbset2_q1.py Using a combination of conditional statements, write a function that converts numerical grades to letter grades. Your overall script should use user input methods to ask the user for a numerical grade to convert and should print out a sentence in which the original entered grade and the converted garde are embedded. Solution: pbset2_q2.py If your solution in 2. used composite expressions as conditions, can you rework if such that only simple expressions are used? Solution: pbset2_q3.py Recursion is the idea that a function can call itself. By modifying the parameters that are provided to the “inside” call, we can modulate how many times a certain function will run. For example, we can write the following function: def sum_numbers_between(a,b): if a == b: return a else: return a + sum_numbers_between(a+1,b) my_sum = sum_numbers_between(0, 10) print(my_sum) In this scenario, each call of the function either returns a if the range is only composed of a (i.e. if the range has a == b) or a + sum_numbers_between(a+1,b). In the second case, note that a is incremented: this ensures that it will at some point satisfy the first condition. Using the same idea as the one exposed in the snippet above, build a function that sums up all the even numbers between two values a and b where a &lt;= b. Solution: pbset2_q4.py","@type":"BlogPosting","url":"https://mcataford.github.io/TalkPythonToMe/problems/conditionals-problems-solutions.html","headline":"Control flow","dateModified":"2018-02-12T10:05:23-05:00","datePublished":"2018-02-12T10:05:23-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mcataford.github.io/TalkPythonToMe/problems/conditionals-problems-solutions.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <link rel="stylesheet" href="/TalkPythonToMe/assets/main.css">
  <link type="application/atom+xml" rel="alternate" href="https://mcataford.github.io/TalkPythonToMe/feed.xml" title="Learning Python" />
  
</head>


  <body>

    <html>

  <head>
    <title></title>

    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" rel="stylesheet"/>
    <link href="https://mcataford.github.io//TalkPythonToMe/css/base.css" rel="stylesheet"/>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.bundle.min.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-39212350-4"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-39212350-4');
    </script>

    
  </head>

  <body>

    <header class="page-header">
      <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <a class="navbar-brand" href="#">Learn Python</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarText" aria-controls="navbarText" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarText">
          <ul class="navbar-nav mr-auto">
            <li class="nav-item active">
              <a class="nav-link" href="https://mcataford.github.io//TalkPythonToMe/">Home <span class="sr-only">(current)</span></a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="https://mcataford.github.io//TalkPythonToMe/#lessons">Main course</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="https://mcataford.github.io//TalkPythonToMe/#workshops">Workshops</a>
            </li>
            <li class="nav-item">
              <a class="nav-link disabled" href="https://mcataford.github.io//TalkPythonToMe/#resources">Resources</a>
            </li>
          </ul>
          <span class="navbar-text"></span>
        </div>
      </nav>
    </header>

    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Control flow</h1>
    <h3 class="p-name">Conditional statements and branching</h3>
    
  </header>
  <hr>

  

  
  <div class="alert alert-success" role="alert">
    <h4 class="alert-heading">All done?</h4>
    <p>Once you are done practice, you should check out the solutions!
    <hr>
    <p class="mb-0">
      <a href="https://mcataford.github.io/TalkPythonToMe/problems/conditionals-problems-solutions.html"><button type="button" class="btn btn-outline-success">Solutions</button></a>
    </p>
  </div>
  

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="truefalse-questions">True/False questions</h1>

<ol>
  <li>
    <p><code class="highlighter-rouge">boolean</code> variables can have three values: <code class="highlighter-rouge">True</code>, <code class="highlighter-rouge">False</code> and <code class="highlighter-rouge">Undefined</code>.</p>

    <p><strong>False</strong>: Boolean values are <strong>binary</strong>, <code class="highlighter-rouge">True</code> or <code class="highlighter-rouge">False</code>.</p>
  </li>
  <li>
    <p>The <code class="highlighter-rouge">contains</code> operator checks whether a certain element is inside a collection.</p>

    <p><strong>False</strong>: <code class="highlighter-rouge">in</code> checks for inclusion in a collection following the format <code class="highlighter-rouge">item in collection</code>.</p>
  </li>
  <li>
    <p>Because they are not <strong>primitives</strong>, strings cannot be compared using <code class="highlighter-rouge">==</code> and <code class="highlighter-rouge">!=</code>.</p>

    <p><strong>False</strong>: While strings are not primitives, they can be compared using the <code class="highlighter-rouge">==</code> and <code class="highlighter-rouge">!=</code> operators.</p>
  </li>
  <li>
    <p>Simple statements can be combined using <code class="highlighter-rouge">and</code> and <code class="highlighter-rouge">or</code> to build more complex boolean expressions.</p>

    <p><strong>True</strong>: Using <code class="highlighter-rouge">and</code> and <code class="highlighter-rouge">or</code> can help you combine simple statements into composite statements.</p>
  </li>
  <li>
    <p>A boolean expression always <strong>evaluates</strong> to a boolean value.</p>

    <p><strong>True</strong>: This separates their operators from the other arithmetic operators.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">if</code> blocks cannot be used alone; they need an accompanying <code class="highlighter-rouge">else</code> block.</p>

    <p><strong>False</strong>: <code class="highlighter-rouge">if</code> blocks are independent and do not need <code class="highlighter-rouge">else</code> blocks.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">elsif</code> blocks allow you to add “alternative conditions” to be evaluated if the ones above are <code class="highlighter-rouge">False</code>.</p>

    <p><strong>False</strong>: <code class="highlighter-rouge">elif</code> allows this, <code class="highlighter-rouge">elsif</code> isn’t a valid keyword.</p>
  </li>
  <li>The following block would only print <code class="highlighter-rouge">Foo</code>:
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">value</span> <span class="o">=</span> <span class="mi">5</span>

 <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="ow">and</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
   <span class="k">print</span><span class="p">(</span><span class="s">"Foo"</span><span class="p">)</span>
 <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">:</span>
   <span class="k">print</span><span class="p">(</span><span class="s">"Bar"</span><span class="p">)</span>
 <span class="k">elif</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">:</span>
   <span class="k">print</span><span class="p">(</span><span class="s">"Baz"</span><span class="p">)</span>
 <span class="k">else</span><span class="p">:</span>
   <span class="k">print</span><span class="p">(</span><span class="s">"Bat"</span><span class="p">)</span>
</code></pre></div>    </div>

    <p><strong>False</strong>: <code class="highlighter-rouge">if</code> blocks are independent from each other. As such, they are all evaluated. <code class="highlighter-rouge">else</code> and <code class="highlighter-rouge">elif</code> are the dependent blocks.</p>
  </li>
  <li>
    <p>The function of <code class="highlighter-rouge">elif</code> and <code class="highlighter-rouge">else</code> blocks can be emulated using <code class="highlighter-rouge">if</code> blocks only, but it is much less efficient.</p>

    <p><strong>True</strong>: Using conditions, it’s possible to emulate <code class="highlighter-rouge">elif</code> and <code class="highlighter-rouge">else</code>, but the syntax is cumbersome.</p>
  </li>
  <li>
    <p><strong>User input</strong> using <code class="highlighter-rouge">input()</code> is non-blocking: the script will continue running and will not wait for the user’s input unless the value is used in a later statement.</p>

    <p><strong>False</strong>: <code class="highlighter-rouge">input()</code> is blocking. Once reached, an <code class="highlighter-rouge">input()</code> call will cause the script to wait until an input is given.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">input()</code> can produce integers, floats or strings, depending on the <code class="highlighter-rouge">type</code> parameter given to it.</p>

    <p><strong>False</strong>: <code class="highlighter-rouge">input()</code> produces strings, which can then be converted at-will.</p>
  </li>
</ol>

<h1 id="short-answer-questions">Short answer questions</h1>

<ol>
  <li>
    <p>Explain the role of <strong>indentation</strong> in blocks such as <code class="highlighter-rouge">if</code>/<code class="highlighter-rouge">elif</code>/<code class="highlighter-rouge">else</code>.</p>

    <p>Indentation is used to delimit what code is part of blocks, it replaces the usage of braces in other languages like C and Java. Indentation however needs to be consistent for the interpreter to recognize when a block ends.</p>
  </li>
  <li>
    <p>Detail one practical example of how <strong>conditional statements</strong> can be used in scripts.</p>

    <p>Conditional statements can be used to <strong>validate</strong> data and prevent crashes: <em>if</em> a value isn’t valid, further operation can be prevented such that no erroneous values or unpredicted behaviour takes place.</p>
  </li>
  <li>
    <p>What happens if a conversion function such as <code class="highlighter-rouge">int()</code> is used on a value that does not contain a number?</p>

    <p>If <code class="highlighter-rouge">int()</code> is used on a non-numerical value, a <code class="highlighter-rouge">ValueError</code> will be raised signalling that an invalid value was given to the function <code class="highlighter-rouge">int()</code>. This will stop the script’s execution.</p>
  </li>
</ol>

<h1 id="programming-questions">Programming questions</h1>

<ol>
  <li>
    <p>Revisit the <a href="https://mcataford.github.io/TalkPythonToMe/problems/basics-problems.html">temperature conversion problem</a> of the last problem set and implement <strong>input validation</strong> for each of your conversion functions. If the value given to your function is below the minimum acceptable value, you should return the lowest converted value possible, and if the value is above the maximum acceptable value, you should return the highest converted value possible. Think of what the bounds of your input should be.</p>

    <p><strong>Solution</strong>: <a href="https://github.com/mcataford/TalkPythonToMe/blob/master/docs/code/problemset2/pbset2_q1.py">pbset2_q1.py</a></p>
  </li>
  <li>
    <p>Using a combination of conditional statements, write a function that <strong>converts</strong> numerical grades to letter grades. Your overall script should use <strong>user input</strong> methods to ask the user for a numerical grade to convert and should print out a sentence in which the original entered grade and the converted garde are embedded.</p>

    <p><strong>Solution</strong>: <a href="https://github.com/mcataford/TalkPythonToMe/blob/master/docs/code/problemset2/pbset2_q2.py">pbset2_q2.py</a></p>
  </li>
  <li>
    <p>If your solution in <em>2.</em> used <strong>composite expressions</strong> as conditions, can you rework if such that only simple expressions are used?</p>

    <p><strong>Solution</strong>: <a href="https://github.com/mcataford/TalkPythonToMe/blob/master/docs/code/problemset2/pbset2_q3.py">pbset2_q3.py</a></p>
  </li>
  <li>
    <p><strong>Recursion</strong> is the idea that a function can call itself. By modifying the parameters that are provided to the “inside” call, we can modulate how many times a certain function will run.</p>

    <p>For example, we can write the following function:</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">def</span> <span class="nf">sum_numbers_between</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
   <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span>
     <span class="k">return</span> <span class="n">a</span>
   <span class="k">else</span><span class="p">:</span>
     <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">sum_numbers_between</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>

 <span class="n">my_sum</span> <span class="o">=</span> <span class="n">sum_numbers_between</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

 <span class="k">print</span><span class="p">(</span><span class="n">my_sum</span><span class="p">)</span>
</code></pre></div>    </div>

    <p>In this scenario, each call of the function either returns <code class="highlighter-rouge">a</code> if the range is only composed of <code class="highlighter-rouge">a</code> (i.e. if the range has <code class="highlighter-rouge">a == b</code>) or <code class="highlighter-rouge">a + sum_numbers_between(a+1,b)</code>. In the second case, note that <code class="highlighter-rouge">a</code> is incremented: this ensures that it will at some point satisfy the first condition.</p>

    <p>Using the same idea as the one exposed in the snippet above, build a function that sums up all the <strong>even</strong> numbers between two values <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code> where <code class="highlighter-rouge">a &lt;= b</code>.</p>

    <p><strong>Solution</strong>: <a href="https://github.com/mcataford/TalkPythonToMe/blob/master/docs/code/problemset2/pbset2_q4.py">pbset2_q4.py</a></p>
  </li>
</ol>

  </div>

  

  <a class="u-url" href="/TalkPythonToMe/problems/conditionals-problems-solutions.html" hidden></a>
</article>
      </div>
    </main>

    
  <footer>
  </footer>
  
  </body>
</html>

  </body>

</html>
